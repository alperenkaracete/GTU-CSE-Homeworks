# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1l4O2vDkfSGP0-ZLV3IvNeiL2nEgKkPfA
"""

def driverFunction():

  import random
#Question 1
  print("Q1----------------------------------------")
  val1 = input("Enter your value: ")
  val2 = input("Enter your value: ")
  val3 = input("Enter your value: ")
  val4 = input("Enter your value: ")
  words=[]
  words.append(val1)
  words.append(val2)
  words.append(val3)
  words.append(val4)
  lengthOfWords = len(words)
  commonWord = findcommonWord(words, 0, lengthOfWords - 1)
  result = ""
  for i in range(len(commonWord)):
    if (commonWord[i]!=None):
      result += str(commonWord[i])
  print(result)
  print()
#Question 2  A
  randomNumbers = random.sample(range(1, 200), 10)
  print("Q2A----------------------------------------")
  Income=0,
  buyAmount=0,
  sellAmount=0
  Income=tradepart1(randomNumbers)
  print(randomNumbers)
  print("Most Incomes is",Income)
  print()

#Question 2  B
  print("Q2B----------------------------------------")
  print(randomNumbers)
  tradepart2(randomNumbers)  
  print()

#Question 3  
  randomList = random.sample(range(1, 20), 10)
  print("Q3----------------------------------------")
  print(randomList)
  print("Most increasing sub array has",findLongestIncreasingSubarray(randomList),"elements.")
  print()

#Question 4  A  
  print("Q4A----------------------------------------")
  randomNumbers1 = random.sample(range(1, 200), 3)
  randomNumbers2 = random.sample(range(1, 200), 3)
  randomNumbers3 = random.sample(range(1, 200), 3)
  randomNumbers4 = random.sample(range(1, 200), 3)
  scores = [randomNumbers1, randomNumbers2, randomNumbers3,randomNumbers4]
  print(scores)
  rows = 4
  columns = 3
  result = findMaximumScoreDynamic(scores, rows, columns)
  print("Best Path:",result[0]) 
  print()

#Question 4  B  
  print("Q4B----------------------------------------")
  arr = [randomNumbers1, randomNumbers2, randomNumbers3,randomNumbers4]
  rows = 4
  columns = 3
  print("Best Path:",findMaximumScore(arr,rows,columns))  
  print()

driverFunction()

def commonPrefixWord(word1, word2):
 
    lenghtWord1 = len(word1) 
    lenghtWord2 = len(word2)
    i = 0
    j = 0
    commonWord = []

    if lenghtWord1 < lenghtWord2:
      goUntil = lenghtWord1
      commonWord = [None] * lenghtWord1

    else: 
      goUntil = lenghtWord2
      commonWord = [None] * lenghtWord2
 
    for i in range(goUntil):
      if word1[i] != word2[i]:
        i = goUntil
      else:    
        commonWord[i] = word1[i]
    return commonWord
 
def findcommonWord(words, start, end):
 
    if start == end:
        return words[start]
 
    if end > start:
     

        mid = start + (end - start) // 2
        word1 = findcommonWord(words, start, mid)
        word2 = findcommonWord(words, mid + 1, end)
 
        return commonPrefixWord(word1, word2)

def tradepart1(prices):

  if len(prices) <= 1:
    return 0

  middle = len(prices) // 2
  leftPrices = prices[:middle]
  rightPrices = prices[middle:]

  leftProfit = tradepart1(leftPrices)
  rightProfit = tradepart1(rightPrices)
  crossProfit,buyAmount,sellAmount = maximumCrossProfit(leftPrices, rightPrices)

  return max(leftProfit, rightProfit, crossProfit)

def maximumCrossProfit(left_prices, right_prices,):
  maxPrice = max(right_prices)
  maxIncome = 0
  buypoint = 0
  sellpoint = 0

  for price in left_prices:
    profit = maxPrice - price
    if (maxIncome < profit):
      maxIncome = profit
      sellpoint = max(right_prices)
      buypoint = price

  return maxIncome,buypoint,sellpoint

def findMinMax(prices):

  income = 0
  maxAndMinNumber = []
  maxNumber = -9999
  minNumber = prices[0]
  buyDayNumber = 0
  sellDayNumber = 999
  if len(prices) == 1:
    maxAndMinNumber.append(prices[0])
    maxAndMinNumber.append(0)
    maxAndMinNumber.append(prices[0])
    maxAndMinNumber.append(0)    

  elif len(prices) == 2:
    if prices[0]>prices[1]:
      maxAndMinNumber.append(prices[1])
      maxAndMinNumber.append(1)
      maxAndMinNumber.append(prices[0])
      maxAndMinNumber.append(0)

    else:
      maxAndMinNumber.append(prices[0])
      maxAndMinNumber.append(0)
      maxAndMinNumber.append(prices[1])
      maxAndMinNumber.append(1)

  else:
    for i in range(len(prices)):
      for j in range(i,len(prices)-1):
        if prices[j+1]-prices[i] > income:
          income = prices[j+1]-prices[i]
          minNumber = prices[i]
          buyDayNumber = i
          maxNumber = prices[j+1]
          sellDayNumber = j+1

    maxAndMinNumber.append(minNumber)
    maxAndMinNumber.append(buyDayNumber)
    maxAndMinNumber.append(maxNumber)
    maxAndMinNumber.append(sellDayNumber)
  return maxAndMinNumber  

def tradepart2(prices):

  actualMinMaxNumbers=findMinMax(prices)
  print ("Buy on Day" ,actualMinMaxNumbers[1],"for",actualMinMaxNumbers[0],"and sell on Day",(actualMinMaxNumbers[3]),"for",actualMinMaxNumbers[2] )

def findMaximumScoreDynamic(scores, rows, columns):

  storeScores = [[(0, []) for _ in range(columns)] for _ in range(rows)]
  storeScores[0][0] = (scores[0][0], [(0, 0)])

  for i in range(rows):
    for j in range(columns):

      if i > 0 and j > 0:
        if storeScores[i][j-1][0] > storeScores[i-1][j][0]:
          storeScores[i][j] = (storeScores[i][j-1][0] + scores[i][j], storeScores[i][j-1][1] + [(i, j)])
        else:
          storeScores[i][j] = (storeScores[i-1][j][0] + scores[i][j], storeScores[i-1][j][1] + [(i, j)])

      elif i == 0 and j > 0:
        storeScores[i][j] = (storeScores[i][j-1][0] + scores[i][j], storeScores[i][j-1][1] + [(i, j)])

      elif i > 0 and j == 0:
        storeScores[i][j] = (storeScores[i-1][j][0] + scores[i][j], storeScores[i-1][j][1] + [(i, j)])
        
  return storeScores[rows-1][columns-1]

def findMaximumScore(scores,rows,columns):

  i = 0
  j = 0
  sum = scores[i][j]

  while i < rows and j < columns:
    if i+1 < rows and j+1 < columns:
        if scores[i+1][j] > scores[i][j+1]:
          sum += scores[i+1][j]
          i += 1
        else:
          sum += scores[i][j+1]
          j += 1  
    else:    
      if j + 1 < columns:
        sum += scores[i][j+1]
      else:  
        sum += scores[i+1][j]
      return sum

def findLongestIncreasingSubarray(array):
    lengthOfArray = len(array)
    count=1
    storeSubArrayCounts = [1] * lengthOfArray
    
    for i in range(1, lengthOfArray):
        for j in range(i):
          if j+1 < i:
            if array[i] > array[j] and array[i]>array[j+1] and array[j]< array[j+1]:
              count +=1  
            else:
              count=1
          storeSubArrayCounts[i] = count+1
    return max(storeSubArrayCounts)